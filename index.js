// =============================================================================
// === index.js ===
// Description: Discord bot for DM file browsing. Sends new messages for folder navigation.
//              Handles oversized items via copy/move, static link, and persistent
//              folder auto-deletion (2hr). Only sends final follow-up on ZIP failure.
// Features:
// - DM-only interaction, paginated listing (`!filelist`).
// - Interactive selection, new message on folder/up navigation.
// - Sends individual files, zips/sends folders.
// - Handles size limits, copies/moves oversized items.
// - Provides static link & 2hr deletion warning for oversized items.
// - Persistent auto-deletion of containing folders.
// =============================================================================

// --- Environment Variables and Dependencies ---
require('dotenv').config();
const {
    Client, GatewayIntentBits, Partials, Events, ActivityType, ChannelType,
    EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType,
    MessageFlags
} = require('discord.js');
const fs = require('fs');
const fsp = require('fs').promises;
const path = require('path');
const archiver = require('archiver');
const os = require('os');

// --- Configuration from .env ---
const token = process.env.DISCORD_BOT_TOKEN;
const fileBrowseRoot = process.env.FILE_BROWSE_ROOT;
const fileLimitFolder = process.env.FILE_LIMIT_FOLDER; // Folder for oversized files/zips
const fileServUrl = process.env.FILE_SERV_URL; // Static URL base for oversized files/zips

// --- Constants ---
const COMMAND_PREFIX = '!';
const BROWSE_ITEMS_PER_PAGE = 10;
const DISCORD_FILE_LIMIT_BYTES = 25 * 1024 * 1024; // 25MB limit (Discord default)
const BROWSE_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes for the entire browse session
const NUMBER_INPUT_TIMEOUT_MS = 30 * 1000; // 30 seconds to type the file number
const AUTO_DELETE_DELAY_MS = 2 * 60 * 60 * 1000; // 2 hours in milliseconds
const INVALID_PATH_CHARS_REGEX = /[<>:"/\\|?*\x00-\x1f]|\.\.|\.$|^\./g;
const DELETION_RECORDS_FILE = 'file_records.json'; // Persistence file

// --- Basic Configuration Validation ---
if (!token) { console.error("FATAL ERROR: DISCORD_BOT_TOKEN not set in .env"); process.exit(1); }
if (!fileBrowseRoot) { console.error("FATAL ERROR: FILE_BROWSE_ROOT not set in .env"); process.exit(1); }
if (!fs.existsSync(fileBrowseRoot)) { console.error(`FATAL ERROR: FILE_BROWSE_ROOT path not found: "${fileBrowseRoot}"`); process.exit(1); }
let sizeLimitFeatureEnabled = true;
if (!fileLimitFolder) { console.warn("Warning: FILE_LIMIT_FOLDER not set. Oversized item handling (including auto-delete) is disabled."); sizeLimitFeatureEnabled = false; }
else if (!fs.existsSync(fileLimitFolder)) { console.warn(`Warning: FILE_LIMIT_FOLDER path not found: "${fileLimitFolder}". Attempting creation...`); try { fs.mkdirSync(fileLimitFolder, { recursive: true }); console.log(`Successfully created FILE_LIMIT_FOLDER: "${fileLimitFolder}"`); } catch (err) { console.error(`Error creating FILE_LIMIT_FOLDER "${fileLimitFolder}":`, err); console.warn(" -> Oversized item handling disabled."); sizeLimitFeatureEnabled = false; } }
if (!fileServUrl && sizeLimitFeatureEnabled) { console.warn("Warning: FILE_LIMIT_FOLDER is set, but FILE_SERV_URL is not. Users won't get a link for oversized items."); }
if (sizeLimitFeatureEnabled) { console.log("File size limit handling & Persistent Folder Auto-Delete (2hr) is ENABLED."); console.log(` -> Oversized items moved/copied to subdirs under: ${fileLimitFolder}`); if (fileServUrl) console.log(` -> Base link provided: ${fileServUrl}`); else console.log(` -> WARNING: No FILE_SERV_URL provided, users won't get a link.`); }
else { console.log("File size limit handling & Auto-Delete is DISABLED."); }

// --- Discord Client Setup (DM Focus) ---
const client = new Client({
    intents: [ GatewayIntentBits.DirectMessages, GatewayIntentBits.MessageContent ],
    partials: [ Partials.Channel, Partials.Message ],
});

// --- Global State ---
/** @type {Map<string, BrowseSession>} */
const activeSessions = new Map();
/** @type {DeletionRecord[]} */
let pendingDeletions = []; // In-memory list of pending deletions
/** @type {Map<string, NodeJS.Timeout>} */
const activeDeletionTimeouts = new Map(); // filePath -> TimeoutID

// =============================================================================
// === Deletion Persistence Types ===
// =============================================================================
/** @typedef {Object} BrowseSession @property {Array<{ name: string; isDirectory: boolean }>} items @property {Array<{ name: string; isDirectory: boolean }>} allDirectoryItems @property {number} currentPage @property {number} totalPages @property {string} currentPath @property {string} originalUser @property {string | null} activeMessageId @property {import('discord.js').InteractionCollector<import('discord.js').ButtonInteraction> | null} buttonCollector @property {import('discord.js').MessageCollector | null} numberInputCollector @property {boolean} getFolderInProgress */
/** @typedef {Object} DeletionRecord @property {string} filePath @property {string} dirPath @property {string} itemName @property {number} scheduledAt @property {number} deleteAt */

// =============================================================================
// === Deletion Persistence Functions ===
// =============================================================================
async function loadDeletionRecords() { let records = []; try { const data = await fsp.readFile(DELETION_RECORDS_FILE, 'utf8'); records = JSON.parse(data); if (!Array.isArray(records)) { console.warn(`[PERSISTENCE] Invalid format in ${DELETION_RECORDS_FILE}. Expected array.`); return []; } console.log(`[PERSISTENCE] Loaded ${records.length} raw records.`); } catch (err) { if (err.code === 'ENOENT') { console.log(`[PERSISTENCE] ${DELETION_RECORDS_FILE} not found. Starting fresh.`); return []; } else if (err instanceof SyntaxError) { console.error(`[PERSISTENCE] Error parsing JSON in ${DELETION_RECORDS_FILE}:`, err.message); return []; } else { console.error(`[PERSISTENCE] Error reading ${DELETION_RECORDS_FILE}:`, err); return []; } } const processedRecords = records.map(r => { if (r && r.filePath && !r.dirPath) { console.log(`[PERSISTENCE] Record for "${r.itemName || r.filePath}" missing dirPath. Calculating.`); r.dirPath = path.dirname(r.filePath); } return r; }).filter(r => { const isValid = r && r.filePath && r.dirPath && r.deleteAt && r.itemName; if (!isValid) console.warn(`[PERSISTENCE] Skipping invalid record:`, r); return isValid; }); console.log(`[PERSISTENCE] Processed ${processedRecords.length} valid deletion records.`); return processedRecords; }
async function saveDeletionRecords(recordsToSave) { try { const data = JSON.stringify(recordsToSave || [], null, 2); await fsp.writeFile(DELETION_RECORDS_FILE, data, 'utf8'); } catch (err) { console.error(`[PERSISTENCE] Error writing to ${DELETION_RECORDS_FILE}:`, err); } }
async function performDeletion(record) { const { filePath, dirPath, itemName } = record; console.log(`[AUTO-DELETE] Attempting deletion for item "${itemName}" by removing directory: ${dirPath}`); const resolvedLimitFolder = path.resolve(fileLimitFolder); const resolvedDirToDelete = path.resolve(dirPath); if (!resolvedDirToDelete.startsWith(resolvedLimitFolder)) { console.error(`[AUTO-DELETE] SECURITY ALERT: Attempted delete outside limit folder "${resolvedLimitFolder}" for dir "${resolvedDirToDelete}". Aborting.`); return; } if (resolvedDirToDelete === resolvedLimitFolder) { console.error(`[AUTO-DELETE] SECURITY ALERT: Attempted delete root limit folder "${resolvedLimitFolder}". Aborting.`); return; } try { await fsp.rm(resolvedDirToDelete, { recursive: true, force: true }); console.log(`[AUTO-DELETE] Successfully deleted directory: ${resolvedDirToDelete} (triggered by item "${itemName}")`); } catch (delErr) { console.error(`[AUTO-DELETE] Error deleting directory ${resolvedDirToDelete}:`, delErr); } finally { const timeoutId = activeDeletionTimeouts.get(filePath); if (timeoutId) { clearTimeout(timeoutId); activeDeletionTimeouts.delete(filePath); } pendingDeletions = pendingDeletions.filter(r => r.filePath !== filePath); await saveDeletionRecords(pendingDeletions); console.log(`[PERSISTENCE] Removed record for "${itemName}" (Dir: ${dirPath}). Remaining: ${pendingDeletions.length}`); } }
function processDeletionRecord(record) { const now = Date.now(); const delay = record.deleteAt - now; if (delay <= 0) { console.log(`[PERSISTENCE] Record for "${record.itemName}" (Dir: ${record.dirPath}) is overdue. Deleting now.`); performDeletion(record).catch(err => console.error(`[PERSISTENCE] Uncaught error during immediate deletion process for ${record.dirPath}:`, err)); } else { console.log(`[PERSISTENCE] Scheduling future deletion for "${record.itemName}" (Dir: ${record.dirPath}) in ${Math.round(delay / 1000)}s.`); const timeoutId = setTimeout(() => { performDeletion(record).catch(err => console.error(`[PERSISTENCE] Uncaught error during scheduled deletion process for ${record.dirPath}:`, err)); }, delay); activeDeletionTimeouts.set(record.filePath, timeoutId); } }
async function scheduleNewDeletion(itemPath, itemName) { const dirToDelete = path.dirname(itemPath); const now = Date.now(); const resolvedLimitFolder = path.resolve(fileLimitFolder); const resolvedDirToDelete = path.resolve(dirToDelete); if (!resolvedDirToDelete.startsWith(resolvedLimitFolder) || resolvedDirToDelete === resolvedLimitFolder) { console.error(`[AUTO-DELETE] SECURITY ALERT: Refusing to schedule deletion for directory "${resolvedDirToDelete}" (triggered by "${itemName}").`); return; } const newRecord = { filePath: itemPath, dirPath: dirToDelete, itemName: itemName, scheduledAt: now, deleteAt: now + AUTO_DELETE_DELAY_MS }; console.log(`[AUTO-DELETE] Scheduling new deletion for item "${itemName}" by removing dir: ${dirToDelete} at ${new Date(newRecord.deleteAt).toLocaleString()}.`); if (!pendingDeletions.some(r => r.filePath === itemPath)) { pendingDeletions.push(newRecord); } else { console.warn(`[AUTO-DELETE] Attempted to schedule duplicate deletion for item path ${itemPath}. Skipping add.`); return; } await saveDeletionRecords(pendingDeletions); const timeoutId = setTimeout(() => { performDeletion(newRecord).catch(err => console.error(`[PERSISTENCE] Uncaught error during newly scheduled deletion process for ${newRecord.dirPath}:`, err)); }, AUTO_DELETE_DELAY_MS); activeDeletionTimeouts.set(itemPath, timeoutId); }

// =============================================================================
// === Helper Functions (Original) ===
// =============================================================================
function sanitizeFolderName(name) { if (!name || typeof name !== 'string') return 'unknown_folder'; const baseName = name.includes('#') ? name.substring(0, name.lastIndexOf('#')) : name; let cleanName = baseName.replace(INVALID_PATH_CHARS_REGEX, '_').replace(/\s+/g, '_'); cleanName = cleanName.replace(/^[_.]+|[_. ]+$/g, '').trim().substring(0, 60); return cleanName === '' ? 'sanitized_folder' : cleanName; }
async function getDirectoryContents(relativePath) { const timestamp = `[${new Date().toLocaleString()}] DIR READ`; const cleanRelativePath = relativePath.replace(/^[/\\]+/, ''); const absolutePath = path.join(fileBrowseRoot, cleanRelativePath); console.log(`${timestamp}: Reading: ${absolutePath} (Relative: '${cleanRelativePath || '/'}')`); const resolvedPath = path.resolve(absolutePath); const resolvedBase = path.resolve(fileBrowseRoot); if (!resolvedPath.startsWith(resolvedBase)) { console.error(`${timestamp}: SECURITY ALERT: Path traversal! Base: "${resolvedBase}", Req: "${absolutePath}", Res: "${resolvedPath}"`); throw new Error("Access denied: Invalid path."); } try { const dirents = await fsp.readdir(absolutePath, { withFileTypes: true }); const directories = []; const files = []; for (const dirent of dirents) { if (dirent.isDirectory()) directories.push({ name: dirent.name, isDirectory: true }); else if (dirent.isFile()) files.push({ name: dirent.name, isDirectory: false }); } directories.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })); files.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })); return [...directories, ...files]; } catch (err) { console.error(`${timestamp}: Error reading directory "${absolutePath}":`, err); if (err.code === 'ENOENT') throw new Error(`Directory not found: '${cleanRelativePath || '/'}'`); if (err.code === 'EACCES') throw new Error(`Permission denied: '${cleanRelativePath || '/'}'`); throw new Error(`Error listing: '${cleanRelativePath || '/'}'`); } }
function generateFileListEmbed(sessionData) { const { items, currentPage, totalPages, currentPath } = sessionData; const startIndex = (currentPage - 1) * BROWSE_ITEMS_PER_PAGE; const endIndex = startIndex + BROWSE_ITEMS_PER_PAGE; const pageItems = items.slice(startIndex, endIndex); let description = pageItems.map((item, index) => { const itemNumber = startIndex + index + 1; const escapedName = item.name.replace(/([`*_~|\\])/g, '\\$1'); const prefix = item.isDirectory ? '📁' : '📄'; return `\`${String(itemNumber).padStart(3)}. \` ${prefix} ${escapedName}`; }).join('\n') || (currentPath === '' ? 'The base directory is empty.' : 'This directory is empty.'); let title = `📂 File Browser`; if (currentPath) { const displayPath = `/${currentPath.replace(/\\/g, '/')}`.substring(0, 100) + (currentPath.length > 100 ? '...' : ''); title += ` (${displayPath})`; } const embed = new EmbedBuilder().setTitle(title.substring(0, 256)).setDescription(description.substring(0, 4096)).setFooter({ text: `Page ${currentPage}/${totalPages} | Items ${items.length === 0 ? 0 : startIndex + 1}-${Math.min(endIndex, items.length)} of ${items.length}` }).setColor(0x5865F2); const row1 = new ActionRowBuilder().addComponents( new ButtonBuilder().setCustomId('browse_up').setLabel('Up').setStyle(ButtonStyle.Secondary).setEmoji('⬆️').setDisabled(currentPath === ''), new ButtonBuilder().setCustomId('browse_prev').setLabel('Prev').setStyle(ButtonStyle.Secondary).setEmoji('⬅️').setDisabled(currentPage <= 1), new ButtonBuilder().setCustomId('browse_next').setLabel('Next').setStyle(ButtonStyle.Secondary).setEmoji('➡️').setDisabled(currentPage >= totalPages) ); const row2 = new ActionRowBuilder().addComponents( new ButtonBuilder().setCustomId('browse_choose').setLabel('Choose Item').setStyle(ButtonStyle.Success).setEmoji('✅').setDisabled(items.length === 0), new ButtonBuilder().setCustomId('browse_get_folder').setLabel('Get Folder (ZIP)').setStyle(ButtonStyle.Primary).setEmoji('📦').setDisabled(currentPath === '' || !sessionData.allDirectoryItems.some(item => !item.isDirectory)), new ButtonBuilder().setCustomId('browse_cancel').setLabel('Cancel').setStyle(ButtonStyle.Danger).setEmoji('✖️') ); return { embeds: [embed], components: [row1, row2] }; }
async function sendFile(dmChannel, filePath, userTag, relativeBrowsePath) { const timestamp = `[${new Date().toLocaleString()}] SEND FILE`; const fileName = path.basename(filePath); const cleanRelativePath = relativeBrowsePath.replace(/^[/\\]+/, ''); try { const stats = await fsp.stat(filePath); if (!stats.isFile()) { console.warn(`${timestamp}: Attempted non-file: ${filePath}`); await dmChannel.send(`⚠️ \`${fileName}\` is not a file.`).catch(() => {}); return false; } const fileSizeMB = (stats.size / (1024 * 1024)).toFixed(2); console.log(`${timestamp}: Preparing "${fileName}" (${fileSizeMB} MB) for ${userTag} from '/${cleanRelativePath}'`); if (stats.size <= DISCORD_FILE_LIMIT_BYTES) { console.log(`${timestamp}: Sending "${fileName}" directly...`); await dmChannel.send({ content: `Sending \`${fileName}\` (${fileSizeMB} MB)...`, files: [filePath] }); console.log(`${timestamp}: Success sending "${fileName}".`); return true; } else { console.warn(`${timestamp}: File "${fileName}" (${fileSizeMB} MB) exceeds limit.`); if (!sizeLimitFeatureEnabled) { await dmChannel.send(`⚠️ File \`${fileName}\` (${fileSizeMB} MB) too large, handling disabled.`); return false; } const sanitizedUserFolder = sanitizeFolderName(userTag); const destinationDirectory = path.join(fileLimitFolder, sanitizedUserFolder, cleanRelativePath); const destinationPath = path.join(destinationDirectory, fileName); console.log(`${timestamp}: Copying oversized "${fileName}" to: "${destinationPath}"`); try { await fsp.mkdir(destinationDirectory, { recursive: true }); await fsp.copyFile(filePath, destinationPath); console.log(`${timestamp}: Success copying "${fileName}".`); await scheduleNewDeletion(destinationPath, fileName); let messageContent = `⚠️ File \`${fileName}\` (${fileSizeMB} MB) is too large for Discord.\n` + `✅ It has been copied for you. **The folder containing it will be automatically deleted in 2 hours.**\n*Larger files may take a few moments to appear.*`; if (fileServUrl) { messageContent += `\nFind it within this location:\n${fileServUrl}`; console.log(`${timestamp}: Provided static URL: ${fileServUrl}`); } else { messageContent += `\n(No public URL configured for access).`; console.log(`${timestamp}: Oversized file copied, but no FILE_SERV_URL provided.`); } await dmChannel.send(messageContent); return true; } catch (copyError) { console.error(`${timestamp}: FAILED copy "${fileName}" to "${destinationPath}":`, copyError); await dmChannel.send(`❌ File \`${fileName}\` (${fileSizeMB} MB) too large, copy failed. Contact admin.`); return false; } } } catch (err) { console.error(`${timestamp}: Error processing file "${fileName}" at path "${filePath}":`, err); let errorMsg = `❌ Error accessing \`${fileName}\`.`; if (err.code === 'ENOENT') errorMsg = `❌ File \`${fileName}\` not found.`; else if (err.code === 'EACCES') errorMsg = `❌ Permission denied: \`${fileName}\`.`; await dmChannel.send(errorMsg); return false; } }
async function handleArchive(dmChannel, tempZipFilePath, targetZipFileName, userTag, relativeBrowsePath) { const timestamp = `[${new Date().toLocaleString()}] SEND ARCHIVE`; const cleanRelativePath = relativeBrowsePath.replace(/^[/\\]+/, ''); let currentZipPath = tempZipFilePath; try { const stats = await fsp.stat(currentZipPath); const fileSizeMB = (stats.size / (1024 * 1024)).toFixed(2); console.log(`${timestamp}: Processing ZIP "${targetZipFileName}" (${fileSizeMB} MB) for ${userTag} from '/${cleanRelativePath}'`); if (stats.size <= DISCORD_FILE_LIMIT_BYTES) { console.log(`${timestamp}: Sending ZIP "${targetZipFileName}" directly...`); await dmChannel.send({ content: `Sending ZIP \`${targetZipFileName}\` (${fileSizeMB} MB)...`, files: [{ attachment: currentZipPath, name: targetZipFileName }] }); console.log(`${timestamp}: Success sending "${targetZipFileName}".`); return true; } else { console.warn(`${timestamp}: ZIP "${targetZipFileName}" (${fileSizeMB} MB) exceeds limit.`); if (!sizeLimitFeatureEnabled) { await dmChannel.send(`⚠️ ZIP \`${targetZipFileName}\` (${fileSizeMB} MB) too large, handling disabled.`); return false; } const sanitizedUserFolder = sanitizeFolderName(userTag); const destinationDirectory = path.join(fileLimitFolder, sanitizedUserFolder, cleanRelativePath); const destinationPath = path.join(destinationDirectory, targetZipFileName); let finalDestinationPath = null; console.log(`${timestamp}: Attempting move oversized ZIP "${targetZipFileName}" to: "${destinationPath}"`); try { await fsp.mkdir(destinationDirectory, { recursive: true }); await fsp.rename(currentZipPath, destinationPath); console.log(`${timestamp}: Success move (rename) "${targetZipFileName}".`); finalDestinationPath = destinationPath; currentZipPath = null; } catch (moveError) { if (moveError.code === 'EXDEV') { console.warn(`${timestamp}: Move failed (EXDEV). Fallback copy/delete for "${targetZipFileName}".`); try { await fsp.copyFile(tempZipFilePath, destinationPath); console.log(`${timestamp}: Success copy "${targetZipFileName}" (cross-device).`); finalDestinationPath = destinationPath; } catch (copyError) { console.error(`${timestamp}: FAILED cross-device copy "${targetZipFileName}" to "${destinationPath}":`, copyError); await dmChannel.send(`❌ ZIP \`${targetZipFileName}\` (${fileSizeMB} MB) too large, copy failed. Contact admin.`); return false; } } else { console.error(`${timestamp}: FAILED move (rename) "${targetZipFileName}" to "${destinationPath}":`, moveError); await dmChannel.send(`❌ ZIP \`${targetZipFileName}\` (${fileSizeMB} MB) too large, move failed. Contact admin.`); return false; } } if (finalDestinationPath) { await scheduleNewDeletion(finalDestinationPath, targetZipFileName); } else { console.error(`${timestamp}: Could not determine final path for "${targetZipFileName}" to schedule deletion.`); } let messageContent = `⚠️ ZIP archive \`${targetZipFileName}\` (${fileSizeMB} MB) is too large for Discord.\n` + `✅ It has been moved/copied for you. **The folder containing it will be automatically deleted in 2 hours.**\n*Larger files may take a few moments to appear.*`; if (fileServUrl) { messageContent += `\nFind it within this location:\n${fileServUrl}`; console.log(`${timestamp}: Provided static URL: ${fileServUrl}`); } else { messageContent += `\n(No public URL configured for access).`; console.log(`${timestamp}: Oversized ZIP handled, but no FILE_SERV_URL provided.`); } await dmChannel.send(messageContent); return true; } } catch (err) { console.error(`${timestamp}: Error processing ZIP "${targetZipFileName}" at path "${currentZipPath}":`, err); let errorMsg = `❌ Error accessing ZIP \`${targetZipFileName}\`.`; if (err.code === 'ENOENT') errorMsg = `❌ Generated ZIP \`${targetZipFileName}\` not found (internal error).`; await dmChannel.send(errorMsg); return false; } finally { if (currentZipPath) { try { await fsp.unlink(currentZipPath); console.log(`${timestamp}: Cleaned temp zip: ${currentZipPath}`); } catch (cleanupError) { if (cleanupError.code !== 'ENOENT') console.error(`${timestamp}: Error cleaning temp zip ${currentZipPath}:`, cleanupError); } } else { console.log(`${timestamp}: Temp zip moved, no finally cleanup for: ${tempZipFilePath}`); } } }

// =============================================================================
// === Bot Event Handlers ===
// =============================================================================

client.once(Events.ClientReady, async (readyClient) => {
    console.log(`✅ Logged in as ${readyClient.user.tag}`); console.log(`📂 File browse root: ${fileBrowseRoot}`); console.log(`🕒 DM File Browser Bot is Ready!`); readyClient.user.setActivity('files in DMs', { type: ActivityType.Watching });
    pendingDeletions = await loadDeletionRecords(); if (sizeLimitFeatureEnabled) { console.log("[PERSISTENCE] Processing existing deletion records..."); if (pendingDeletions.length > 0) { pendingDeletions.forEach(record => processDeletionRecord({ ...record })); console.log("[PERSISTENCE] Finished processing existing records."); } else { console.log("[PERSISTENCE] No valid existing deletion records to process."); } } else { console.log("[PERSISTENCE] Skipping deletion record processing as feature is disabled."); pendingDeletions = []; }
});

function setupButtonCollector(browseMessage, dmChannelId) { const collector = browseMessage.createMessageComponentCollector({ componentType: ComponentType.Button, time: BROWSE_TIMEOUT_MS }); collector.on('collect', buttonInteractionHandler); collector.on('end', async (collected, reason) => { const currentSession = activeSessions.get(dmChannelId); const isStillActiveCollector = currentSession?.buttonCollector === collector; console.log(`[COLLECTOR END] Button collector ended for message ${browseMessage.id}. Reason: ${reason}. IsActive: ${isStillActiveCollector}`); if (reason !== 'navigated' && isStillActiveCollector) { console.log(`[SESSION END] Session for DM ${dmChannelId} ending. Reason: ${reason}.`); const endedSession = activeSessions.get(dmChannelId); endedSession?.numberInputCollector?.stop('parent_ended'); if (endedSession?.getFolderInProgress) endedSession.getFolderInProgress = false; activeSessions.delete(dmChannelId); console.log(`[SESSION END] Removed session for DM ${dmChannelId}.`); try { const finalBrowseMessage = await browseMessage.channel.messages.fetch(browseMessage.id).catch(() => null); if (finalBrowseMessage?.editable) { let finalContent = `**Session Ended.**`; if (reason === 'time') finalContent = `**Session Timed Out.**`; if (reason === 'cancelled') finalContent = `**Session Cancelled.**`; const disabledComponents = finalBrowseMessage.components.map(row => ActionRowBuilder.from(row).setComponents(row.components.map(c => ButtonBuilder.from(c).setDisabled(true)))); await finalBrowseMessage.edit({ content: finalContent, components: disabledComponents }).catch(e => console.warn(`[COLLECTOR END] Failed edit final msg ${browseMessage.id}: ${e.message}`)); } } catch (editError) { if (editError.code !== 10008) console.warn(`[COLLECTOR END] Could not edit final message ${browseMessage.id} on end (Reason: ${reason}): ${editError.message}`); } } else if (reason === 'navigated') { console.log(`[COLLECTOR END] Collector for ${browseMessage.id} ended due to navigation.`); } else if (!isStillActiveCollector) { console.log(`[COLLECTOR END] Collector for ${browseMessage.id} ended, but is no longer active. Doing nothing.`); } }); return collector; }

async function buttonInteractionHandler(i) {
    const dmChannelId = i.channelId; const currentSession = activeSessions.get(dmChannelId); const buttonTimestamp = `[${new Date().toLocaleString()}] BTN ${i.customId}`;
    if (!currentSession) { try { await i.reply({ content: "Session ended or invalid.", flags: [MessageFlags.Ephemeral] }); } catch {} return; }
    if (i.user.id !== currentSession.originalUser) { try { await i.reply({ content: "This isn't for you.", flags: [MessageFlags.Ephemeral] }); } catch {} return; }
    if (currentSession.numberInputCollector || currentSession.getFolderInProgress) { try { await i.reply({ content: "ℹ️ Please wait for current action.", flags: [MessageFlags.Ephemeral] }); } catch {} return; }
    console.log(`${buttonTimestamp}: Clicked by ${i.user.tag} (ID: ${i.user.id}) on msg ${i.message.id} in DM ${dmChannelId}.`);
    const currentBrowseMessage = i.message;
    try {
        switch (i.customId) {
            case 'browse_up':
                if (currentSession.currentPath === '') { await i.reply({ content: "Cannot go up from root.", flags: [MessageFlags.Ephemeral] }); return; }
                await i.deferUpdate(); const parentPath = path.dirname(currentSession.currentPath); const finalParentPath = (parentPath === '.') ? '' : parentPath;
                try {
                    const parentContents = await getDirectoryContents(finalParentPath); currentSession.currentPath = finalParentPath; currentSession.currentPage = 1; currentSession.allDirectoryItems = parentContents; currentSession.items = parentContents; currentSession.totalPages = Math.max(1, Math.ceil(currentSession.items.length / BROWSE_ITEMS_PER_PAGE)); const { embeds: parentEmbeds, components: parentComps } = generateFileListEmbed(currentSession);
                    try { const disabledComponents = currentBrowseMessage.components.map(row => ActionRowBuilder.from(row).setComponents(row.components.map(c => ButtonBuilder.from(c).setDisabled(true)))); await currentBrowseMessage.edit({ components: disabledComponents }); console.log(`[NAVIGATE UP] Disabled buttons on old message: ${currentBrowseMessage.id}`); } catch (editErr) { console.warn(`[NAVIGATE UP] Could not disable buttons on old message ${currentBrowseMessage.id}: ${editErr.message}`) }
                    if (currentSession.buttonCollector) { currentSession.buttonCollector.stop('navigated'); console.log(`[NAVIGATE UP] Stopped collector for old message: ${currentBrowseMessage.id}`); }
                    const newBrowseMessage = await i.channel.send({ embeds: parentEmbeds, components: parentComps }); console.log(`[NAVIGATE UP] Sent new browse message: ${newBrowseMessage.id}`); currentSession.buttonCollector = setupButtonCollector(newBrowseMessage, dmChannelId); console.log(`[NAVIGATE UP] Attached new collector to message: ${newBrowseMessage.id}`); currentSession.activeMessageId = newBrowseMessage.id;
                } catch (dirError) { console.error(`${buttonTimestamp}: Error getting parent directory contents ("${finalParentPath}"):`, dirError); try { await i.followUp({ content: `❌ Error navigating up: ${dirError.message}`, flags: [MessageFlags.Ephemeral] }); } catch {} }
                break;
            case 'browse_prev': case 'browse_next':
                await i.deferUpdate(); if (i.customId === 'browse_prev' && currentSession.currentPage > 1) currentSession.currentPage--; else if (i.customId === 'browse_next' && currentSession.currentPage < currentSession.totalPages) currentSession.currentPage++; else return; const { embeds: pageEmbeds, components: pageComps } = generateFileListEmbed(currentSession); await currentBrowseMessage.edit({ embeds: pageEmbeds, components: pageComps });
                break;
            case 'browse_choose':
                await i.deferUpdate(); const totalItems = currentSession.items.length; if (totalItems === 0) { try { await i.followUp({ content: "No items to choose.", flags: [MessageFlags.Ephemeral] }); } catch {} break; }
                const promptMsgNumber = await i.followUp({ content: `✅ Enter item number (\`1-${totalItems}\`). Expires ${NUMBER_INPUT_TIMEOUT_MS / 1000}s.`, flags: [MessageFlags.Ephemeral], fetchReply: true }); const numberFilter = m => m.author.id === currentSession.originalUser && m.channel.id === dmChannelId;
                currentSession.numberInputCollector = i.channel.createMessageCollector({ filter: numberFilter, time: NUMBER_INPUT_TIMEOUT_MS, max: 1 });
                currentSession.numberInputCollector.on('collect', async msg => {
                    const numberInputStr = msg.content.trim(); const numberInput = parseInt(numberInputStr, 10); try { await promptMsgNumber.delete(); } catch (e) { if (e.code !== 10008) console.warn(`${buttonTimestamp} Failed delete prompt:`, e.message); }
                    const updatedSession = activeSessions.get(dmChannelId); if (!updatedSession) return; updatedSession.numberInputCollector = null;
                    if (isNaN(numberInput) || numberInput < 1 || numberInput > updatedSession.items.length) { try { await i.followUp({ content: `⚠️ Invalid number 1-${updatedSession.items.length}.`, flags: [MessageFlags.Ephemeral] }); } catch {} return; }
                    const selectedIndex = numberInput - 1; const selectedItem = updatedSession.items[selectedIndex]; if (!selectedItem) { try { await i.followUp({ content: `⚠️ Error finding item ${numberInput}.`, flags: [MessageFlags.Ephemeral] }); } catch {} return; }
                    if (selectedItem.isDirectory) { console.log(`${buttonTimestamp}: User selected directory: "${selectedItem.name}"`); updatedSession.currentPath = path.join(updatedSession.currentPath, selectedItem.name); updatedSession.currentPage = 1; try { updatedSession.allDirectoryItems = await getDirectoryContents(updatedSession.currentPath); updatedSession.items = updatedSession.allDirectoryItems; updatedSession.totalPages = Math.max(1, Math.ceil(updatedSession.items.length / BROWSE_ITEMS_PER_PAGE)); const { embeds: dirEmbeds, components: dirComps } = generateFileListEmbed(updatedSession); try { const oldBrowseMessage = currentBrowseMessage; const disabledComponents = oldBrowseMessage.components.map(row => ActionRowBuilder.from(row).setComponents(row.components.map(c => ButtonBuilder.from(c).setDisabled(true)))); await oldBrowseMessage.edit({ components: disabledComponents }); console.log(`[NAVIGATE] Disabled buttons on old message: ${oldBrowseMessage.id}`); } catch (editErr) { console.warn(`[NAVIGATE] Could not disable buttons on old message ${currentBrowseMessage.id}: ${editErr.message}`) } if (updatedSession.buttonCollector) { updatedSession.buttonCollector.stop('navigated'); console.log(`[NAVIGATE] Stopped collector for old message: ${currentBrowseMessage.id}`); } const newBrowseMessage = await i.channel.send({ embeds: dirEmbeds, components: dirComps }); console.log(`[NAVIGATE] Sent new browse message: ${newBrowseMessage.id}`); updatedSession.buttonCollector = setupButtonCollector(newBrowseMessage, dmChannelId); console.log(`[NAVIGATE] Attached new collector to message: ${newBrowseMessage.id}`); updatedSession.activeMessageId = newBrowseMessage.id; } catch (dirError) { console.error(`${buttonTimestamp}: Error entering directory "${selectedItem.name}":`, dirError); try { await i.followUp({ content: `❌ Error entering directory: ${dirError.message}`, flags: [MessageFlags.Ephemeral] }); } catch {} updatedSession.currentPath = path.dirname(updatedSession.currentPath); if (updatedSession.currentPath === '.') updatedSession.currentPath = ''; } }
                    else { console.log(`${buttonTimestamp}: User selected file: "${selectedItem.name}"`); const fullFilePath = path.join(fileBrowseRoot, updatedSession.currentPath, selectedItem.name); await sendFile(i.channel, fullFilePath, i.user.tag, updatedSession.currentPath); }
                });
                currentSession.numberInputCollector.on('end', async (collected, reason) => { const latestSession = activeSessions.get(dmChannelId); if (latestSession) latestSession.numberInputCollector = null; if (reason === 'time') { try { await promptMsgNumber.delete(); } catch {} try { await i.followUp({ content: "⏰ Timed out.", flags: [MessageFlags.Ephemeral] }); } catch {} } });
                break;
            case 'browse_get_folder':
                await i.deferReply({ flags: [MessageFlags.Ephemeral] }); const sessionForFolder = currentSession;
                if (!sessionForFolder || sessionForFolder.getFolderInProgress) { if(sessionForFolder) await i.editReply("ℹ️ Folder retrieval in progress.").catch(()=>{}); break; } if (sessionForFolder.currentPath === '') { await i.editReply("❌ Cannot 'Get Folder' on root.").catch(()=>{}); break; }
                const filesInFolder = sessionForFolder.allDirectoryItems.filter(item => !item.isDirectory); if (filesInFolder.length === 0) { await i.editReply("ℹ️ No files in folder to zip.").catch(()=>{}); break; }
                const sourceFolderName = path.basename(sessionForFolder.currentPath) || 'root_contents'; const targetZipFileName = `${sanitizeFolderName(sourceFolderName)}.zip`; const sourceDirectoryPath = path.join(fileBrowseRoot, sessionForFolder.currentPath); const sanitizedUsername = sanitizeFolderName(i.user.username); const tempZipPath = path.join(os.tmpdir(), `discordbot_${sanitizedUsername}_${Date.now()}.zip`);
                console.log(`${buttonTimestamp}: User requested ZIP for "${sessionForFolder.currentPath}". ${filesInFolder.length} files. Temp: "${tempZipPath}" Target: "${targetZipFileName}"`); await i.editReply(`📦 Creating ZIP \`${targetZipFileName}\` for \`${sourceFolderName}\` (${filesInFolder.length} files)...`).catch(()=>{});
                sessionForFolder.getFolderInProgress = true; let success = false; let currentTempPathForCleanup = tempZipPath; let zipError = null; // Variable to track if zip failed
                try { const output = fs.createWriteStream(currentTempPathForCleanup); const archive = archiver('zip', { zlib: { level: 6 } }); const archivePromise = new Promise((resolve, reject) => { output.on('close', resolve); archive.on('warning', (err) => console.warn(`${buttonTimestamp}: Archiver warn:`, err)); archive.on('error', (err) => reject(new Error(`Archiver error: ${err.message}`))); output.on('error', (err) => reject(new Error(`Write stream error: ${err.message}`))); }); archive.pipe(output); for (const fileItem of filesInFolder) { const currentLoopSession = activeSessions.get(dmChannelId); if (!currentLoopSession || !currentLoopSession.getFolderInProgress) throw new Error("Folder retrieval cancelled."); archive.file(path.join(sourceDirectoryPath, fileItem.name), { name: fileItem.name }); } await archive.finalize(); await archivePromise; console.log(`${buttonTimestamp}: ZIP created: ${currentTempPathForCleanup} (${archive.pointer()} bytes)`); success = await handleArchive(i.channel, currentTempPathForCleanup, targetZipFileName, i.user.tag, sessionForFolder.currentPath); currentTempPathForCleanup = null; }
                catch (err) { zipError = err; /* Capture error */ console.error(`${buttonTimestamp}: FAILED ZIP process for "${sessionForFolder.currentPath}":`, zipError); let errorMsg = `❌ Error creating ZIP for \`${sourceFolderName}\`.`; if (zipError.message.includes("cancelled")) errorMsg = `⚠️ Folder retrieval cancelled.`; await i.followUp({ content: errorMsg, flags: [MessageFlags.Ephemeral] }).catch(() => {}); success = false; }
                finally { const finalSessionState = activeSessions.get(dmChannelId); if (finalSessionState) finalSessionState.getFolderInProgress = false; if (currentTempPathForCleanup) { try { await fsp.unlink(currentTempPathForCleanup); console.log(`${buttonTimestamp}: Cleaned leftover temp zip: ${currentTempPathForCleanup}`); } catch (cleanupErr) { if (cleanupErr.code !== 'ENOENT') console.error(`${buttonTimestamp}: Error cleaning leftover temp zip ${currentTempPathForCleanup}:`, cleanupErr); } } console.log(`${buttonTimestamp}: Get Folder (ZIP) finished for "${sessionForFolder.currentPath}". Success: ${success}. Flag reset.`); if (!success) { const finalStatus = `❌ Failed to process ZIP for \`${sourceFolderName}\`. Please check logs or contact admin.`; if (zipError == null) { /* Only send if zip didn't already error */ await i.followUp({ content: finalStatus, flags: [MessageFlags.Ephemeral] }).catch(() => {}); } } }
                break;
            case 'browse_cancel':
                await i.deferUpdate(); console.log(`${buttonTimestamp}: User cancelled session.`); currentSession.buttonCollector?.stop('cancelled'); if (currentSession.getFolderInProgress) { currentSession.getFolderInProgress = false; console.log(`${buttonTimestamp}: Get Folder flag cleared by cancel.`); }
                break;
            default: await i.reply({ content: "❓ Unknown button.", flags: [MessageFlags.Ephemeral] });
        } // end switch
    } catch (error) { console.error(`${buttonTimestamp}: Error processing button ${i.customId}:`, error); try { await i.followUp({ content: `❌ An error occurred: ${error.message}`, flags: [MessageFlags.Ephemeral] }); } catch {} const errorSession = activeSessions.get(dmChannelId); if (errorSession) errorSession.getFolderInProgress = false; }
}

client.on(Events.MessageCreate, async (message) => {
    if (message.guild || message.author.bot || !message.content.startsWith(COMMAND_PREFIX)) return; if (message.channel.type !== ChannelType.DM) return;
    const args = message.content.slice(COMMAND_PREFIX.length).trim().split(/ +/); const command = args.shift().toLowerCase(); const dmChannelId = message.channel.id; const userId = message.author.id; const userTag = message.author.tag; const username = message.author.username; const timestamp = `[${new Date().toLocaleString()}] CMD ${command}`;
    if (command === 'filelist') {
        console.log(`${timestamp}: Received from ${userTag} (DM: ${dmChannelId})`);
        if (activeSessions.has(dmChannelId)) { await message.reply("ℹ️ Active session exists. Cancel (`✖️`) or wait.").catch(()=>{}); return; }
        let browseMessage;
        try {
            const sessionData = { items: [], allDirectoryItems: [], currentPage: 1, totalPages: 1, currentPath: '', originalUser: userId, activeMessageId: null, buttonCollector: null, numberInputCollector: null, getFolderInProgress: false }; activeSessions.set(dmChannelId, sessionData);
            sessionData.allDirectoryItems = await getDirectoryContents(sessionData.currentPath); sessionData.items = sessionData.allDirectoryItems; sessionData.totalPages = Math.max(1, Math.ceil(sessionData.items.length / BROWSE_ITEMS_PER_PAGE)); const { embeds, components } = generateFileListEmbed(sessionData);
            browseMessage = await message.reply({ embeds, components, fetchReply: true }); console.log(`[SESSION START] Initial browse message sent: ${browseMessage.id}`);
            sessionData.activeMessageId = browseMessage.id; sessionData.buttonCollector = setupButtonCollector(browseMessage, dmChannelId); console.log(`[SESSION START] Attached initial collector to message: ${browseMessage.id}`);
        } catch (err) { console.error(`${timestamp}: Error starting session for ${userTag}:`, err); activeSessions.delete(dmChannelId); await message.reply(`❌ Error starting file browser: ${err.message}`).catch(() => {}); }
    }
});

// =============================================================================
// === Error Handling & Login ===
// =============================================================================
client.on('error', error => console.error(`[${new Date().toLocaleString()}] Discord Client Error:`, error)); client.on('warn', warning => console.warn(`[${new Date().toLocaleString()}] Discord Client Warning:`, warning));
process.on('SIGINT', () => { console.log("SIGINT received, shutting down..."); client.destroy(); process.exit(0); }); process.on('SIGTERM', () => { console.log("SIGTERM received, shutting down..."); client.destroy(); process.exit(0); });
console.log("Attempting to log in to Discord...");
client.login(token).catch(err => { console.error("!!!!!!!!!!!!!!!! LOGIN FAILED !!!!!!!!!!!!!!!!"); console.error(err); if (err.code === 'DisallowedIntents') console.error("\nHint: Ensure 'Direct Messages' and 'Message Content' Intents are enabled."); else if (err.code === 'TokenInvalid') console.error("\nHint: Check DISCORD_BOT_TOKEN in .env."); process.exit(1); });